%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% iso8859-2

%%%                                    %%%
%%% ©ablona bakaláøské práce na MFF UK %%%
%%%                                    %%%
%%% (c) Franti¹ek ©trupl, 2005         %%%
%%%                                    %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% POZOR: Úprava bakaláøské práce je závislá rovnì¾ na volbì jednostranného resp. oboustranného tisku.
%%%        Bli¾¹i informace naleznete v dokumentu Úprava bakaláøské práce, který se nalézá na adrese:
%%%        http://www.mff.cuni.cz/studium/obecne/bplayout/pok12mo4.pdf

\documentclass[12pt,notitlepage]{report}
%\pagestyle{headings}
\pagestyle{plain}

% \frenchspacing aktivuje pou¾ití nìkterých èeských typografických pravidel

\usepackage[latin2]{inputenc} % nastavuje pou¾ité kódování, u¾ivatelé Windows zamìní latin2 za cp1250
%\usepackage[czech]{babel}
\usepackage{a4wide} % nastavuje standardní evropský formát stránek A4
%\usepackage{index} % nutno pou¾ít v pøípadì tvorby rejstøíku balíèkem makeindex
%\usepackage{fancybox} % umo¾òuje pokroèilé rámeèkování :-)
\usepackage{graphicx} % nezbytné pro standardní vkládání obrázkù do dokumentu
\usepackage{amsfonts}
\usepackage{amsmath}

\usepackage[left=2.5cm]{geometry} % nastavení dané velikosti okrajù

%\newindex{default}{idx}{ind}{Rejstøík} % zavádí rejstøík v pøípadì pou¾ití balíku index

% promenne:
\newcommand{\vedouci}{prof. RNDr. Peter Vojtá¹, DrSc.}
\newcommand{\ja}{Petr Cvengro¹}
\newcommand{\katedra}{Katedra softwarového in¾enýrství}
\newcommand{\nazev}{Univerzální doporuèovací systém}
\newcommand{\datum}{DATUM}
\newcommand{\vedoucimail}{Peter.Vojtas@mff.cuni.cz}

% prikazy s parametry
\newcommand{\fig}[4][13]{
    \begin{figure}[!ht]
        \vspace{3mm}
        \begin{center}
            \includegraphics[width=#1cm]{#2}
            \caption{#3}
            \label{#4}
        \end{center}
    \end{figure}
}
% parameters: [width in cm], filename, caption, label


\title{Název práce}   % tyto dvì polo¾ky jsou zde v podstatì formálnì, ve skuteènosti nejsou nikde 
\author{Petr Cvengro¹} % dále v dokumentu pou¾ity

%\date{}

\begin{document}

%\csprimeson % zapne jednoduché psaní èeských uvozovek pomocí klasických znakù, ale potom pozor 
             % na originální apostrofy, které budou chybnì interpretovány!!!

%%% Následuje první, úvodní, strana bakaláøské práce. Jednotlivé polo¾ky nahraïte dle vlastních
%%% údajù. Zmìnit podle konkrétní délky jednotlivých polo¾ek mù¾ete i zalomení øádkù.
\begin{titlepage}
\begin{center}
\ \\

\vspace{15mm}

\large
Univerzita Karlova v Praze\\
Matematicko-fyzikální fakulta\\

\vspace{5mm}

{\Large\bf DIPLOMOVÁ PRÁCE}

\vspace{10mm}

%%% Aby vlo¾ní loga v¹e správnì fungovalo, je tøeba mít soubor logo.eps nahraný v pracovním adresáøi,
%%% tj. v adresáøi, kde se nachází pøekládaný zdrojový soubor. Soubor logo.eps je mo¾né získat napø.
%%% na adrese: http://www.mff.cuni.cz/fakulta/symboly/logo.eps
\includegraphics[scale=0.3]{pics/logo.jpg} 

\vspace{15mm}

%\normalsize
{\Large \ja}\\ % doplòte va¹e jméno
\vspace{5mm}
{\Large\bf \nazev}\\ % doplòte název práce
\vspace{5mm}
\katedra\\ % doplòte název katedry èi ústavu
\end{center}
\vspace{15mm}

\large
\noindent Vedoucí diplomové práce: \vedouci % doplòte odpovídající údaje
%%% dal¹í øádek mù¾ete ve vìt¹inì pøípadù (tj. pokud údaje uvedené vý¹e nejsou pøíli¹ dlouhé) zru¹it
\hskip20mm 
\vspace{1mm} 

\noindent Studijní program: Informatika, Softwarové systémy, Softwarové in¾enýrství % doplòte odpovídající údaje
%%% dal¹í øádek mù¾ete ve vìt¹inì pøípadù (tj. pokud údaje uvedené vý¹e nejsou pøíli¹ dlouhé) zru¹it
%\hskip20mm 

\vspace{20mm}

\begin{center}
2010-2011 % doplòte rok vzniku va¹í bakaláøské práce
\end{center}

\end{titlepage} % zde konèí úvodní strana

\normalsize % nastavení normální velikosti fontu
\setcounter{page}{2} % nastavení èíslování stránek
\ \vspace{10mm} 

\noindent Na tomto místì mohou být napsána pøípadná podìkování (vedoucímu práce, konzultantovi, tomu, kdo pùjèil software, literaturu, poskytl data apod.). % doplòte vlastní text

\vspace{\fill} % nastavuje dynamické umístìní následujícího textu do spodní èásti stránky
\noindent Prohla¹uji, ¾e jsem svou diplomovou práci napsal samostatnì a výhradnì s pou¾itím citovaných pramenù. Souhlasím se zapùjèováním práce.

\bigskip
\noindent V Praze dne \datum \hspace{\fill}\ja\\ % doplòte patøièné datum, jméno a pøíjmení

%%%   Výtisk pak na tomto míste nezapomeòte PODEPSAT!
%%%                                         *********

\tableofcontents % vkládá automaticky generovaný obsah dokumentu

\newpage % pøechod na novou stránku

%%% Následuje strana s abstrakty. Doplòte vlastní údaje.
\noindent
Název práce: \nazev\\
Autor: \ja\\
Katedra (ústav): \katedra\\
Vedoucí diplomové práce: \vedouci\\
e-mail vedoucího: \vedoucimail\\

\noindent Abstrakt:  V pøedlo¾ené práci studujeme ... Uvede se abstrakt v rozsahu 80 a¾ 200 slov. %Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Ut sit amet sem. Mauris nec turpis ac sem mollis pretium. Suspendisse neque massa, suscipit id, dictum in, porta at, quam. Nunc suscipit, pede vel elementum pretium, nisl urna sodales velit, sit amet auctor elit quam id tellus. Nullam sollicitudin. Donec hendrerit. Aliquam ac nibh. Vivamus mi. Sed felis. Proin pretium elit in neque. Pellentesque at turpis. Maecenas convallis. Vestibulum id lectus. Fusce dictum augue ut nibh. Etiam non urna nec mi mattis volutpat. Curabitur in tortor at magna nonummy gravida.\\

\noindent Klíèová slova: klíèová slova (3 a¾ 5)

\vspace{10mm}

\noindent
Title: Universal Recommender System\\
Author: \ja\\
Department: Department of Software Engineering\\
Supervisor: \vedouci\\
Supervisor's e-mail address: \vedoucimail\\

\noindent Abstract: In the present work we study ... Uvede se anglický abstrakt v rozsahu 80 a¾ 200 slov. %Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Ut sit amet sem. Mauris nec turpis ac sem mollis pretium. Suspendisse neque massa, suscipit id, dictum in, porta at, quam. Nunc suscipit, pede vel elementum pretium, nisl urna sodales velit, sit amet auctor elit quam id tellus. Nullam sollicitudin. Donec hendrerit. Aliquam ac nibh. Vivamus mi. Sed felis. Proin pretium elit in neque. Pellentesque at turpis. Maecenas convallis. Vestibulum id lectus. Fusce dictum augue ut nibh. Etiam non urna nec mi mattis volutpat. Curabitur in tortor at magna nonummy gravida.\\

\noindent Keywords: klíèová slova (3 a¾ 5) v angliètinì

\newpage

%%% Následuje text bakaláøské práce èlenìný do kapitol, které se èíslují, oznaèí názvy a graficky oddìlí.
%%% Nedoporuèuje se pou¾ívat víc ne¾ dvì úrovnì èíslování kapitol, viz pøíklad ní¾e.

\chapter{Introduction}
    \label{introduction}

    A present-day internet user is facing a plentitude of options. E-shops are offering a wide choice of various products, internet newspapers publish thousands of articles every day, loads of videos are published or uploaded by users every second. When a user is deciding what to buy, read or see, there are by far too many options to browse and choose the optimal one. Search engines don't help much, because a query like ``find something I would like'' is too vague. That's where recommender systems emerge. They help users to deal with the information overload, retailers to offer the most appropriate product for each client which resutls in increased custumer satisfaction and loyalty. 
    
    The key feature of recommender systems is \emph{personalization}. Unlike search engines, recommenders take into account the personality and past behaviour of each user. A typical recommender wouldn't present the same set of items to two different users.
    
    Recommender systems are programs operating on large amount of data in software systems. Recommender systems try to present items such as books, music, news, etc. that are likely to be interesting for a given user. These systems may be helpful for users that are choosing between a large number of items and aren't willing to browse information about all available items.
    
    Traditional recommender systems are specific to a particular domain of recommended items. Our view is more general and involves domain independence and a prediction of any type of relationship between the objects in the domains. The thesis aims to create a prototype of a \emph{Universal Recommender} system, a system applicable to various domains, prediciting relationships of the given type using already known relationships.
    
    In the introductory chapter we describe the basic structure of the thesis. Then we give a formal definition of a recommender system. Finally we review projects and papers that have been created on the universal recommender topic.
    
    \section{Thesis Structure}
        \label{thesis_structure}
        In the \emph{\ref{introduction} Introduction} chapter we describe some basic ideas of the thesis, give a formal definition of a recommender system and explore the works that have been made on the topic.
        ...
    \section{Thesis Concepts}
        The section describes the main concepts of the thesis. We list the most important features, establish the purpose of the thesis and briefly show the distinction from the existing work.
        
        The main concepts of the thesis are:
        \begin{description}
                \item[Problem analysis and design of a solution.] The main goal of the work is to analyze the problem of a universal recommender, to create an architecture of the recommender system, design its interfaces and provide an implementation draft. The intefaces should be usable in real-world applications.
                \item[Domain independence.] The recommender should work on any domain it's addapted to. It can't rely on any domain-specific assumptions. 
                \item[Using various relationships.] For the recommendation, the recommender should be able to use any number of relationships available in the domain.
                \item[Recommending given relationship.] The recommender should be able to predict any given relationship, not just the ``rating'' relationship as most recommenders do.
                \item[A recommender, not a framework.] The adaptation to the given domain should be simple and without any need for programming. As opposed to recommendation frameworks that give resources to implement a recommender, our system should be a complete recommender ready to be addapted and used on an arbitrary domain.
                \item[Pluggable user interface.] The recommender should contain a web-based user interface for presenting the recommendations. The interface should be pluggable an existing web application, so that it can look like a part of the system and the user doesn't have to leave system web pages. 
                \item[Verification on various domains.] The recommender should be addapted to at least three domains to verify its universality and usability of the recommender interfaces. 
        \end{description}
        \subsection{Out of Scope}
        The section lists features that are relevant but out of the thesis scope. 
        \begin{description}
            \item[] preciznost a skalovatelnost implementace, optimalizace a rychlost dane implemetnace
            \item[]dalsi hustoficury, ktere nestihnu, 
            \item[]nebudu merit vykon v case jenom nejak plus minus asymptoticky
            \item[Central server for multiple systems.] A single Unresyst instance isn't intended to be used as a central server for multiple domains - a Unresyst instance always refers to a single domain. Unresyst doesn't deal with matching the same subjects and objects appearing in multiple systems. 
            \item[Collecting user preference] Unresyst doesn't help the system collecting any user actions for recommending. Implicit and explicit user feedback can be used for generating recommendations in Unresyst, but it has to be handled by the outer system and passed to Unresyst in the form of business rules and relationships. 
        \end{description}

        
    \section{Definitions}
        \label{definitions}
        In this section we give some basic definitions of terms and problems that appear in the whole thesis.
        
        \subsection{Basic Terms}
        \label{basic_terms}
            The basic terms used both in definitions and throughout the tesis are:
            \begin{description}
                \item[Subject]: Subject of a recommendation is an entity to which the recommender presents its recommendations. A subject can be a user as well as a user group or any other entity.
                \item[Object]: Object of a recommendation is an entity which can be recommended to subjects. Objects can be books, songs, or any other entities.  
             \end{description}
        
        \subsection{Recommender System}
        \label{def_recommender_system}
            Informally, a recommender system is a system that presents some chosen \emph{objects} to a given \emph{subject}. The objects are chosen so that they are likely to invoke a positive response of the subject.
            
            Similarly to the recommender problem definition in \cite{survey}, we formally define the recommendation as choosing the object $o_s$ for each subject $s$, so that the object maximizes the subject's utility $u_R$:
            \begin{equation}
            \label{eq_recommender_problem}
            \forall s \in S: o_s = \underset{o \in O}{arg \  max \  u_R(s, o)},
            \end{equation}
            where $S$ is the subject domain, $O$ is the object domain. The usefulness of the object to the subject is measured by the $u_R$ function, $u_R: S \times O \to T$, where $T$ is a totally ordered set. 
            
            There are two differences to the definition in \cite{survey}. Firstly, we define our function on a \emph{Subject domain $S$}, instead of the User domain. In our view an adressee of a recommendation can be anything, not just a user. In some cases $S=O$, e.g. when we are recommending new friends to a user.  Secondly, we parametrize the utility function by the given relationship type $R$. In our system a recommendation can be done in the means of the given relationship type. 
            
        \subsection{Relationship Prediction}
            \label{relationship_prediction}
            \emph{Relationship Prediction} $\hat{u}$ is an approximation of the utility function $u$: 
            \begin{equation}
                \label{eq_relationship_prediction}
                \hat{u}: S \times O \to [0, 1]  \times E,
            \end{equation}
            where $E$ is a set of textual explanations.
            
            For a given subject-object pair, $\hat{u}$ gives:
            \begin{description}
                \item[Relationship prediction rate:] the predicted probabilitity of occurence of the given relationship type between the subject and the object. It's a number between $0$ and $1$. The value $1$ is reserved for the subject-object pairs, that are already connected by the relationship of the given type. Thus, the objects with relationship prediction $1$ aren't presented to the subject Usually the recommended object are presented ordered by the rate. The exact value of the rate doesn't have to be presented to the subject.
                \item[Explanation:] a textual explanation why the object has been recommended. For some recommender algorithms explanations aren't available.
                %\item[Relationship metadata values]: coming soon
            \end{description}

            For instance, if the object and subject domains are community server users and the relationship type is friendship, for Alice and Bob the recommender can give a relationship prediction of $0.75$, with an explenation, that they have four friends in common. This means that the predicted probability of friendship between Alice and Bob is $0.75$. 


        \subsection{Recommendation}
            \label{recommendation}
            For the given subject, the \emph{Recommender System} or \emph{Recommender} performs a \emph{Recommendation} $\varrho$ -- it chooses at most $N$ subjects with the highest relationship prediction rate:
            \begin{equation}
                \label{eq_recommendation}
                \varrho: S \to \mathcal{P}_{\leq N}(O),
            \end{equation}
            where $\mathcal{P}_{\leq N}(O)$ is a $N$-limited powerset of $O$ (the set of subsets of $O$ of cardinality lower or equal to $N$).
            
            The recommender always chooses exactly $N$ objects, except the case where there are less than $N$ objects available for recommendation. The chosen objects are presented to the subject ordered by the Recommendation Rate.
            
            For instance, using the example in \ref{relationship_prediction}, the friendship recommender presents ten other community server users to Alice. The users are sorted by the relationship prediction rate which reflects the number of mutual friends.
        
        \subsection{Adaptation}
        \subsection{Relationship for Recommender}
    
    \section{Operations in Recommender Systems}
        \label{operations}
        In a recommendation system, some common operations are:
        \begin{description}
            \item[Recommender setup:] After a configuration of the recommender is done, the recommender has to prepare itself for recommending objects. This operation can be pretty time consuming, as this doesn't have to be performed very often. 
            \item[Recommendation (see \ref{recommendation}):] Recommendation is the most common operation for a recommender system. Choosing objects with the highest Recommendation Rate among all objects can be a very expensive operation. That's why most recommender systems introduce some kind of index, enabling the recommender to recommend objects real-time. This operation should be performed very fast, ideally in a constant time.
            \item[Adding an object:] The recommender needs to perform this operation when an object is added to the system. For the recommender systems with an index, the object must be added to the index so that it can be recommended to the subjects. Adding an object corresponds to e.g. adding a new book to the system. The operation isn't as common as the recommendation, it doesn't have to be performed that fast - the adding of new object can appear in the recommendations after some time.
            \item[Adding a subject:] As for the new object, for the recommender systems with an index, the new subject has to be added to the recommendation index. Adding a subject corresponds to e.g. registering a new user to the system. 
            \item[Adding a relationship:] Adding a new relationship can be a quite common operation. It should be performed quite quickly but not necessarily real-time. Adding a relationship corresponds e.g. to user's rating of a book. 
            
        \end{description}
    
    \section{Related Work}
        \label{related_work}
        Neco o recommenderech obecne. List komercne fungujicich. 
        
        The recommender research area has been strongly influenced by the Netflix prize \cite{netflix_wiki}. In the years 2006-2009, the Netflix DVD rental company held a competition on improving their recommender, awarded by the grand prize of US\$1,000,000. To the competition participants, Netflix exposed a data set of over hundred millions of ratings. Over 48,000 teams from 182 different countries participated, the competition had a huge response in both scientific and mainstream media. A paper describing the winning solution was publicly released \cite{netflix_solution}. The competition brought benefits for the Netflix company as well as for the whole recommender research world \cite{netflix_benefit}  Unfortunately, the second Netflix prize was canceled after some user privacy issues \cite{netflix_end}.
        
        \subsection{Domain Independent Recommenders}
            \label{domain_independent_recommenders}
            The idea of a domain-independent recommender isn't completely new. The most notable project in this field is an open-source project called \emph{AURA} (The Advanced Universal Recommendation Architecture) \cite{aura}. The project was supported by Sun and later by Oracle, but since the end of 2009 there's been no activity on the source code repository. The experimental music recommender based on AURA, \emph{The Music Explaura} \cite{music_explaura} seems to be inactive. The project aimed to create a universal hybrid recommender system, combining the two most used approaches: collaborative filtering and content-based recommendation (see \ref{collaborative_filtering}, \ref{content_based_filtering}). The system should have been working above a data store. More on the project can be found in \cite{aura_wiki}.  
            
            Another notable work on universal recommender is a US software pattent application \emph{Universal system and method for representing and predicting human behavior} \cite{patent}. The text contains a mixture of marketing proclamations, ideas on the recommender architecture, description of recommender and machine-learning algorithms and ideas on capturing implicit user ratings. In our opinion, the recommending methods presented in the text could be working well only on very small sets of data, for larger data sets, the ammount of time needed for performing some basic operations wouldn't be acceptable. The final paragraph, trying to claim everything around, from vector object representation to capturing the action of user adjusting the volume on his music player, gives a negative example of where the idea of software patents can lead. As far as we know there's no functional recommender system based on this patent. 
            
            white paper, 
            Duine - trochu moc se tam pracuje s tim user ratingem
    \section{Other Aspects of Recommender Systems}
        \subsection{Relation to Other Research Areas}
            vztah k vyhledavani, machine learningu, statistice, 
        \subsection{Legal Issues}


\chapter{Recommender Algorithms}
    \label{algorithms}
    In the chapter we list and describe algorithms that are commonly used for recommending. Finally we choose a combination of algorithms that will be used for the universal recommender.
    
    Vetsina jede na ratingy. rict, proc je/neni dobre jet na ratingy. ze to vlastne ratingy taky zvlada (likes relationsip + prediction rate)

    \section{Content-based Methods}
        \label{content_based_filtering}
        Content-based filtering methods are one of the oldest and most popular methods for recommending. The principle of these methods is recommending objects that are similar to some objects, the user liked in past. The similarity among the objects is determined from the values of their characteristics. 
        
        
        They are widely used in text-based applications, for recommending documents or web sites \cite{survey}. One of the implementations of a content based based recommender is the Music Genome Project \cite{wiki_genome}. A musician analyzes each song in the system, giving a value for each of the musical characteristics. 
        
        The figure \ref{pic_content_based} shows an example of a content based recommender. The known relationships are marked as full arrows, the calculated or inserted object similarity by the dotted arrow and the predicted relationship by the dashed arrow.
        
        \fig{pics/content-based.png}{Content-based Methods}{pic_content_based}

        \subsection{Definition}
        More formally, according to \cite{survey}, the utility function $u_R(s, o)$ of subject $s$, object $o$ and relationship $R$ is estimated based on the utilities $u_R(s, o_i)$ assigned by subject $s$ to objects $o_i \in O$ that are similar to object $o$. The method can be enhanced by introducing \emph{subject profiles} containing information about subjects' tastes. 
        \subsection{Benefits and Drawbacks}
        The accuracy of the provided recommendations strongly depends on the similarity determination. If the items are characterized properly and the subjects tend to like uniform sets of objects, the recommender can be pretty successful, as \cite{wiki_genome} mentioned above. However there are several drawbacks of the method, as mentioned in \cite{survey}:
        \begin{description}
            \item[Limited content analysis:] The set of characteristics assigned to each object is always limited and is never able to fully characterize the object. Moreover the values of the characteristics have to be determined either manually which is time-consuming or automatically which currently works well only for text documents. 
            \item[Overspecialization:] The method always recommends objects that are similar to some that the subject liked in the past. Therefore the recommender never broadens subjects' horizon by recommending diverse objects.
            \item[New user problem:] When a new subject emerges in the system and has no relationships to objects, the system cannot make any recommendations to the subject.
        \end{description}

        \subsection{Suitability for The Universal Recommender}
        In a domain-independent recommender we cannot assume that there are sufficient object characteristics available. The only way how to get object characteristics and similarities is to obtain them during the addaption to a new domain. As this is usually quite a complicated operation, the universal recommender wouldn't be much helpful for most of the domains. Therefore the content-based methods aren't very suitable for the universal recommender.

    \section{Collaborative Filtering}
        \label{collaborative_filtering}
        Collaborative filtering is currently one of the most widely used technique for recommending. Market leaders as Amazon.com, Last.fm or Digg.com use recommenders based on collaborative filtering \cite{wiki_collaborative}. 
        
        For recommending an object to a subject, the method uses relationships between other subjects and objects. For a given subject $s$, the algorihm finds subjects that have relationships to most of the objects that $s$ has. Recommended objects are then taken from other objects related to found subjects. 
        
        In the figure \ref{pic_collaborative} there is a simplified example of a recommendation made by collaborative filtering. The full arrows represent already known relationships. The two subjects both have a relation to one item and therefore they are treated as similar. The recommendation is marked by the dashed arrow. An object to be recommended is chosen from the similar subject's related objects so that the subject isn't related to the object.
        
        \fig{pics/collaborative.png}{Collaborative Filtering}{pic_collaborative}
        
        The collaborative filtering methods can be divided into several groups. The overview of the groups can be seen in the figure \ref{pic_collaborative_groups}), names of the techniques and algorithms belonging to the given groups are in italics.
        
        \fig{pics/collaborative_groups.png}{Classification of the collaborative filtering algorithms}{pic_collaborative_groups}
        
        By the manner in which the unknown relationships are predicted, collaborative filtering methods can be divided into two groups: \emph{Memory-based} and \emph{Model-based} \cite{survey}.
        
        \subsection{Memory-based Collaborative Filtering}
            Memory based (or heuristic-based) methods are historically the first collaborative filtering methods. In memory-based prediction methods, the predictions of possible relationships are counted as an aggreagate of the known subject-object relationships. The aggregate function can be a simple average or some more sofisticated measure using relative differences to average ratings or inter-subject similarity. 
            
            \emph{Neighbourhood methods} belong to this category. For recommending an object to a subject they use relationships of the neighbouring subject or object (depending on the recommender being subject-based or object-based). The neighbour is defined as the subject/object having the highest similarity to the given subject/object. The similarity can be counted in many ways, including the Pearson correlation coefficient \cite{survey}. 
            
            The memory-based methods can further be devided into two groups by the direction which is used for recommending: \emph{Subject-based} or \emph{Object-based}. 
            
            \subsubsection{Subject-based Collaborative Filtering}
                Subject-based (or user-based) methods are centered to the subjects. In this traditional variation, the similarity of subjects is computed. More formally, according to \cite{survey}, the utility function $u_R(s, o)$ of subject $s$, object $o$ and relationship $R$ is estimated based on the utilities $u_R(s_j, o)$ assigned to object $o$ by the subjects $s_j \in S$  who are similar to subject $s$. Usually the similarity between subjects is determined by comparing their relationships to objects. 
            \subsubsection{Object-based Collaborative Filtering}
                Object-based (or item-based) methods have been popularized by Amazon.com \cite{wiki_collaborative}. The principle of the algorithm remains the same, but the algorithm starts at the objects and similarity between objects is computed. Objects sharing the same related subjects are taken as similar. The objects recommended to a subject are taken from objects similar to those the subject is related to. The method can also be used for showing products that are related to a product that is viewed by an anonymous user, as can be seen in the Amazon.com product catalogue: ``Users that bought product $x$ also bought product $y, z$''. The easiest implementation of the item-based memory-based collaborative filtering is the \emph{Slope One} method \cite{wiki_slope_one}. 
                
                Another way how to measure the similarity is the cosine measure, which is used in the \emph{Item-to-Item} algorithm patented by Amazon.com \cite{amazon}. The objects are represented as vectors. To count similarity between two objects, subjects that have a relationship to both of these objects are taken. Each such subject represents a dimension in the object vectors, the value is determined from the subject's rating or $0/1$ (the subject has bought/viewed the object or not). The similarity between two objects is then counted as a cosine of the object vectors \cite{amazon}.

        \subsection{Model-based Collaborative Filtering}
            Model-based recommenders use machine-learning techniques to learn a \emph{model} that predicts unknown relationships. The known relationships are used as training data for the model. The machine-learning techniques include \emph{Bayesian networks}, \emph{latent factor models}, or \emph{artificial neural networks} \cite{survey}.
            
            Latent semantic models use vectors to represent subjects and objects \cite{bellkor_ieee}. For objects, the values in the vectors mean some characteristics of the object. This approach is similar to the one used in content-based filtering (\ref{content_based_filtering}). The difference is in obtaining the vectors: the values in object vectors aren't submitted by a human expert, both subject and object vectors are learned from the known data by various techniques. Therefore the technique is domain-independent. 
            
            Subject and object vectors allow to project the subjects and object into multidimensional space. Recommended objects are those that are ``near'' the given subject in the multidimensional space. Some common techniques for measuring the subject-object distance are vector cosine and dot product. Some dimensions can be coupled with some known object characteristics as genre for movies \cite{bellkor_ieee}. But the meaning of most of the dimensions can hardly be discovered, as they aren't designed by a human but a machine-learining technique. Consequently, the recommenders using matrix factorization usually aren't able to give reasons for their recommendations. 
            
            Figure \ref{pic_latent} shows some users and items projected to a simplified two-dimensional space. Their nature determines their positions in the space. Items that are near each user are likely to produce a positive response from the user and hence they are good for recommendations. 
            
            \fig{pics/latent.png}{Latent factor model recommender}{pic_latent} 

            \subsubsection{Matrix Factorization}
            \label{matrix_factorization}
            The main challenge in latent factor models is computing the subject and object vectors. One of the methods for computing them is \emph{matrix factorization}. The method was used by the BellKor team in the winning solution of the Netflix grand prize \cite{bellkor_ieee}. Since then the matrix factorization has become a dominant method for model-based collaborative filtering recommenders.
            
            The method is described in \cite{bellkor_ieee}. Relationships between subject and objects are projected to a subject-object matrix. For ratings, the values in the matrix are the subject's actual ratings of the appropriate object. For other relationships there are zeros and ones in the matrix. This matrix is decomposed into vectors so that the dot product between a subject and object vector gives the actual or predicted value on the appropriate coordinates in the subject-object matrix. The decomposition could be done by the \emph{single value decomposition} technique, but in \cite{bellkor_ieee} a better method is proposed: The known values are used directly to learn the vectors, using a minimization of the regularized squared error. The learning can be done either by the \emph{stochastic gradient descent} method or by \emph{alternating least squares}. The named methods are thoroughly studied in the section \ref{algorithm_implementation}.
            
        \subsection{Benefits and Drawbacks}
        \label{cf_benefits_drawbacks}
        
        In general, collaborative filtering methods are currently the most used and the most successful methods for recommending. When properly used, they provide high accuracy and scalability for large ammount of data. However they have some drawbacks too \cite{survey}.
        \begin{description}
            \item[Cold start problem:] As for the conteng-based method, the system doesn't have any data about a new subject. For a user being a subject, this problem can be solved by asking the user to enter some data. This approach is used in the Netflix system. A new user is given a questionnaire for rating some chosen movies \cite{bellkor_2009}. Another solution to the problem is using a hybrid recommender (\ref{hybrid_recommenders}). 
            A similar problem occurs when a new object is added to the system, it's not related to any subject and therefore it can never be recommended. This can be solved also by a hybrid recommender (\ref{hybrid_recommenders}). 
            \item[Sparsity:] The subject-object matrix is usually very sparse - the number of known relationships is very small compared to the number of relationships that should be predicted. Therefore, in most of the collaborative filtering methods, the objects related to few subjects are seldom recommended. This drawback is overcome by some of the model-based methods, e.g. matrix factorization \cite{bellkor_ieee}.
            \item[Grey sheep problem:] This problem is mentioned in \cite{knowledge_spain}. In the system, there might be subjects whose preferences aren't consistently similar to other subjects. Therefore they don't belong to any preference subejct group and they can't get any accurate recommendations.
         \end{description}
        \subsection{Suitability for The Universal Recommender}
        One of the biggest advantage of collaborative filtering is its domain independence. Generally, the algorithms don't assume any properties of subjects or objects, they just use the relationships between subjects and objects to make recommendations. Of course, the recommender tuned for a particular domain can't be used directly for other domain, but the core algorithm is domain-independent.
        
        The universal recommender proposed in \cite{white_paper} is based on the idea of matrix factorization, which is a model-based collaborative filtering technique. Therefore, the collaborative filtering methods are very suitable for a universal recommender.
    
    \section{Knowledge-based Recommenders}
        \label{knowledge_based}
        
        Although the main focus in the recommender research field is on collaborative filtering, possibilities of knowledge-based recommenders are still being studied.
        
        There are many approaches to knowledge-based recommending. One of them is presented in \cite{knowledge_burke}. The user interaction to the system is similar as in the case of performing a search. At first, the  user specifies an item that he/she likes. Then the system iteratively presents similar items to the user. The user further specifies his/her preferences, like ``I would like a more romantic/adventurous movie''. This continues until the user is fully specified with the presented item.
        
        One problem of the aproach is that the recommendations aren't personal. There're no user profiles in the system, so the recommendations are based only on data given by the user during the search. The author describes how to reduce this disadvantage in \cite{integrating_burke}. The items found by the knowledge-based recommender are sorted by the integrated collaborative filter. Another problem of this approach is bothering the user. The user has to fully specify his preferences in order to get some good recommendations. Although the system leads the user through the search, it can take a lot of time to find the right item.
        
        The article \cite{knowledge_spain} proposes a bit different approach. Their knowledge-based recommender is trying to solve the ``cold start problem'' (see \ref{collaborative_filtering}). When a new user registers to the system, he/she is asked to choose an example of an item he/she likes in the item catalogue. Then the user is asked to compare the item to some other items, using a scale from zero to one, determining how much the item is preferred over the other. An underlying algorithm exploits this knowledge to the whole item catalogue and uses the data for making recommendations. This approach is a bit better than the first described one, as it bothers the user only once - when he/she is registering. Nevertheless new users are more sensitive to being asked a lot of questions and there's a risk, that the user leaves for a rival system. The presented recommender is only a theoretical suggestion, there might be some problems with scalability to large numbers of users and items.
        
        Recommendation by ordering is also discussed in \cite{order}. The authors of the article describe an advanced algorithm for exploiting the known relative preferences to the whole domain. The performance evaluations of the presented algorithm look very promising. Nevertheless, obtaining reliable relative preferences without bothering the user is diffcult and requires some non-trivial domain knowledge. Therefore such a recommender isn't suitable for our universal recommender. 
        
        Another approach to knowledge-based recommender was used in the \emph{RACOFI} system \cite{racofi}. The system consist of a collaborative filtering engine (\emph{COFI}) and a rule applying agent (\emph{RALOCA}). The primary recommendation is done by COFI. The rules are then used for adjusting the recommendation rate or removing objects from recommendations. The rules are applied on \emph{objective} data we know about the subjects and objects, like age and genre respectively. 
        
        The \cite{racofi} report shows that rules can handle boundary cases by removing inappropriate objects for recommendations - e.g. removing too expensive objects when recommending to student subjects. They can also refine recommendations by applying some rules that were found empirically. We find the idea of applying rules for recommending quite interesting, especially when there's not enough data for making other types of recommendation. The other benefit of rule-based recommending is the ability to give explanations why the objects were recommended.

        \fig{pics/knowledge.png}{Knowledge-based Recommender}{pic_knowledge} 
        
        \subsection{Suitability for The Universal Recommender}
        Knowledge can give an added value to a recommender, as some rules are well-known and often cannot be easily extracted from the underlying data. Therefore, if a way how to enter some basic domain-specific rules is found, the knowledge based recommender can be included into the universal recommender. 
            
    \section{Other Domain-specific Methods}
        There are a lot more algorithms for recommending, but all of them rely on specific data that must be available about the subjects or objects for the recommender to work well. As these aren't acceptable for the universal recommender, we list only a few of them.
        \subsection{Social Networks and Link Prediction}
            In social networks, there are links between users, such as the \emph{friends} link. If these are available, the recommender can recommend an object according on what user's friends liked. A schematic picture of the a social network recommender can be seen in the figure \ref{pic_social}.
            
            \fig{pics/social.png}{Recommending in social networks}{pic_social} 

        \subsection{Demographic Filtering}
            When we have some additional information about subjects (users) such as nationality, residence, age or occupation, we can use for determining similarity between the users. A demographic filtering method can be used as an additional measure of user similarity when there's little known about the user's taste. An example of a recommendation made by a demographic filtering recommender can be seen in the figure \ref{pic_demographic}.
            
            \fig{pics/demographic.png}{Demographic Filtering}{pic_demographic} 

    \section{Hybrid Recommenders}
        \label{hybrid_recommenders}
        Hybrid recommenders combine two or more recommending methods in order to enhance their recommendations. There are several ways how to combine them.
         
        For enhancing the success of produced recommendations, we can use a hybrid recommender that uses all its underlying methods when producing any recommendation. The combined methods can be of various types, using various relationships among subjects and objects. A combination of content-based and collaborative filtering is quite popular, possibilities of combining the two methods into a single hybrid recommender are listed in \cite{survey}. The combination of memory-based and model-based collaborative filtering is often used in contemporary commercial recommenders, as in \cite{google_news} 
        
        A hybrid recommender can help to overcome some drawbacks of the recommendation methods, as the \emph{Cold start problem} (see \ref{cf_benefits_drawbacks} for explanations. In this case, when little data is known about a new subject and object, some subsidary recommendation method can be used. This subsidary method wouldn't be suitable for performing the most of the recommendations, but it can make the best of the little data that is available. This approach is used in the default strategy of the Duine recommender framework \cite{duine}.
        
        Figure \ref{pic_hybrid} shows a recommendation for a new user, performed by a hybrid recommender combining social links and collaborative filtering. 
        
        \fig{pics/hybrid.png}{Hybrid Recommender}{pic_hybrid} 
        
        \subsection{Suitability for The Universal Recommender}
        As presented in \cite{white_paper}, the specific combination of methods used in a hybrid recommender depends on the data available in the given domains. Therefore a hybrid recommender can't be generic. The combination of used recommenders would have to be chosen in the addaptation phase. Finding the right combination of recommenders for the specific domain can be non-trivial and thereby hybrid recommenders aren't suitable for a universal recommender. 

    \section{Conclusion}
        \label{algorithm_conclusion}
        In the chapter we have described all common contemporary approaches to recommender systems, their suitability for domain-independent recommending has been evaluated. In a universal recommender we cannot assume that any specific relationships or subject and object properties exists, so our choice narrows a lot. 
        
        From the studied algorithms, the only one that is domain-independent by nature is \emph{collaborative filtering}. All the others are dependent on some specific features of subjects or objects, or they suppose some specific relationships. Therefore, for our universal recommender we choose a collaborative filter. 
        
        There is a lot of types of collaborative filtering algorithms, as can be seen in the \ref{collaborative_filtering} section. The most comprehensive from the described collaborative filters seems to be the \emph{matrix factorization} method. Moreover \cite{white_paper} prooves that all other recommenders, except the knowledge based which isn't menitioned, can be generalized by a recommender based on the matrix factorization collaoborative filtering technique. The only difference to the classical matrix factorization described in \cite{bellkor_ieee} is that the subject and object vectors have to reflect more than one type of relationship. 
        
        For the given reasons, the matrix factorization recommender should be in the core of our universal recommender. 
        
        \subsection{Combining Knowledge-based and Matrix Factorization Recommenders}
        The only method that wasn't generalized by the universal recommender proposed in \cite{white_paper} is the knowledge-based method. As we have shown in \ref{knowledge_based}, simple domain-specific rules can enhance the recommendation accuracy, especially when there's little data available. Hence, incorporating a possibility to enter some simple domain-specific set of rules when addapting the universal recommender to a domain, would be very interesting. We found a few options how to incorporate the evaluation of knowledge rules into a matrix factorization recommender:
        \begin{description}
            \item[Knowledge-based recommender above matrix factorization.] In this variation there're independent knowledge based and matrix factorization recommenders, which corresponds to a hybrid recommender. This approach was used in the RACOFI system \cite{racofi} for other types of collaborative filters. For a relationship prediction, if a rule is available, it would be used for predicting the relationship together with the underlying matrix factorization. If not, only the matrix factorization method would be used. Although this is a possible combination of the recommenders it has a significant drawback. The method introduces a tension between the two recommenders. The results of the matrix factorization method, which should be universal, aren't used in some cases at all, in other cases its results are distorted by the knowledge recommender. This problem can lead to incorrect learning of the model.
            \item[Using matrix factorization, converting the rules into relationships.] Optionally, the rules given in the addaptation to a specific domain, can be converted to relationships between subject/object pairs satisfying the condition in the rule. The matrix factorization recommender would use such relationships as any others and therefore its universality would remain intact. The drawback is the usage of the matrix factorization even for domains and subject/object pairs where a simple knowledge-based recommender would be sufficient. Another problem is the loss of recommendation explanations that would otherwise be available from the knowledge-based recommender.
            \item[Combining the previously mentioned options.] The last possibility is to combine the previously mentioned options. The rules would be divided into two groups: \emph{hard rules} (when a rule condition is satisfied, the object will always be recommended) and \emph{soft rules} (when a rule condition is satisfied, the prediction rate would be decreased or increased). A knowledge-based recommender with the hard rules will be used as described in the first option. The soft rules would be converted into relationships as described in the second option. The distortion of the matrix factorization results would be minimized, the explanations of the knowledge-based recommender will be preserved and the matrix factorization would be used only in the cases when really needed. However matrix factorization distortion remains, as it is not used in all cases. A new problem emerges: The objects recommended by the hard rules would be recommended always and there's no way for a subject to decline them.
        \end{description}
        
        For the given reasons we would choose the second option - \emph{Using matrix factorization, converting the rules into relationships}. Another advantage of this approach is that a standalone knowledge based recommender doesn't have to be implemented, as the modified matrix factorization recommender will be dealing with the rules. The described drawbacks of the method aren't critical and we should be able to overcome them during the implementation. 
        
        
\chapter{Relationships in Studied Systems}
    Tohle mozna vypustit, delam to univerzalne. In the chapter we analyze systems where there are some subjects and objects to recommend. The relationships between the entities in the system are examined and analyzed. The relationships that are suitable for recommendations are chosen and abstracted so they fit the relationships used in the recommender algorithms. 
    \section{Relationships in Existing Systems}
        \label{relationships_in_existing_systems}
        tohle mozna vypustit
        \subsection{Rating}
        \subsection{Friendship}
            
    \section{Relationship Abstraction Summary}
        \label{relationship_abstraction_summary}
        This section summarizes some basic rules that were used when abstracting the relationships. Problems that were met during the analysis are mentioned. Relationships that could not be abstracted are listed here, with reasons why the abstraction wasn't possible.

\chapter{Universal Recommender Design and Implementation}
    \label{design_and_implementation}
    The chapter describes how the Universal Recommender was implemented. We describe the basic architecture of the Universal Recommender. 

% recommendation rate nejak uzpusobit, zavest special konstantu - pro objekty ktere uz subjekt ``vlastni'' - takovy zaklad konfigurace, kdyz to ma, tak mu to nenabizim. 
    \section{Universal Recommender Architecture}
        \label{architecture}
        The Universal Recommender is designed so that it's independent of the domain of the subjects and objects, working only with the abstract relationships. The set of relationships can be extended easily. Several instances of the recommender can be run on a single system, so the Universal Recommender can run with various configurations recommending various objects to various subjects. 
        
        neni nikde native - takze musi stat mimo ten system, mit s nim nejaky rozumny iterface. 
        
        The figure \ref{pic_unrest_adaptation} shows an example how UNREST can be adapted to a domain. In the example we create two recommenders for a domain. A domain expert firstly creates the desired recommenders. In the example it's a \emph{Gear Recommender} and a \emph{Friend Recommender}. Each recommender has two interfaces: \emph{Adaptation Interface} and \emph{Runtime Interface}. The domain expert uses the Adaptation interface to adapt UNREST to the Tennis domain and performs necessary setup to put the recommenders into operation. 
        \fig{pics/unrest_adaptation.png}{Adaptating UNREST to a domain done by a domain expert.}{pic_unrest_adaptation}
        
        In the figure \ref{pic_unrest_runtime} there is a schema of how a system using UNREST operates. The system user accesses the system as usually through its graphical interface (GUI). The UNREST GUI which is a part of UNREST is plugged into the Tennis Server user interface and it presents recommendations to the user. The UNREST GUI as well as the Tennis Server uses the Runtime Interface of both recommenders to get recommendations and to provide information needed for making recommendations. Both recommenders transfer the calls to the UNREST module. The UNREST module generates recommendations and stores them in a database. Recommendations are provided on demand.  
        \fig[17]{pics/unrest_runtime.png}{UNREST common usage.}{pic_unrest_runtime}
        
        obrazek architecture:
            Specific Recommender holds the domain-specific data.
            Recommender provides a domain-independent interface for creating a recommender model, getting recommendations and updating the recommender model.
            Abstractor translates the domain-specific objects into universal ones, converts the given business rules into relationships among subjects and objects.
            Aggregator aggregates all renationships into a single one for subject-object, subject-subject and object-object pairs.
            Recommender Algorithm uses the known relationships among subjects and objects, exploits them to predict all subject-object relationships of the given type.
        
        obrazek build:
            During the build, domain data that have been entered by the domain expert are used for creating a recommender model. 
            Recommender just passes the call to other layers.
            Abstractor goes ove rhe subjects and objects, evalutes the business rules on them, introduces a new relationship or bilas for each rule. It converts subjects and objects to a universal representation that would be used in the rest of UNREST.
            Aggregator aggregates all relationships int o a sinle one for subject-object, subject-subject and object-object pairs, using the given weights. It does the same for biases.
            Recommender Algorithm uses the aggregated relationships to learn a recommender model.
            
        
    \section{Recommender Algorithm Implementation}
        \label{algorithm_implementation}
        
        \subsection{Rule-based Recommender}
            \label{rule_based}
            
            reprezentace pravidel: zvazil jsem xml a rek jasne ne. http://ruleml.org/ .. editing xml is torturing
            maj ale i lepsi syntax http://ruleml.org/submission/ruleml-shortation.html ale stejne to neni zadnej slagr a as far as we know neni pythonovsky interpreter. 
            mam reprezentaci pravidel. typy odpovidaji klasifikaci z \cite{knowledge_spain}, popsane v \ref{knowledge_based} - ale je to napasovane na relationships - podobnost
            
            Accordng to \cite{knowledge_spain}, there are three types of knowledge, the recommender system can deal with:
        \begin{description}
            \item[Catalog knowledge] provids information about objects and their features.
            \item[Fuctional knowledge] provides information about how objects meet subjects' needs. 
            \item[User knowledge] contains information about subjects' needs. 
        \end{description}
        
        
             
        
    \section{Recommendation Viewer}
        \label{viewer}
        The recommendations made by the Universal Recommender can be viewed in a web based application called \emph{Recommendation Viewer}. The application shows recommendations for a chosen subject. It is independent of the object and subject domain. The page for viewing the recommendations can be easily embedded to a webpage.
        %idealne aby to slo rovnou embeddovat do bikebooku
        
        ...
\chapter{Adapting the Universal Recommender to Existing Systems}
    \label{adapting_to_existing_systems}
    Minimalne tri. The process of adapting the Universal Recommender to some existing systems is described in the chapter. The chosen systems work on various domains. Each system has some API, so that the Universal Recommender can easily get data about the objects, subjects and their relationships. The way how to run the Universal Recommender in several instances for a system is described here. Some basic rules for the Universal Recommender configuration are given.
        \subsection{MovieLens data set}
        \subsection{Last.fm}
        \subsection{Bikebook}
        ...

\chapter{Recommender Practice}
    \label{practice}
    In the chapter we describe experience with running the Universal Recommender on various systems. The quality of the recommendations are evaluated for each system. The results are compared to the recommender contained in the system, where relevant. 

    \section{Comparison to Other Recommenders}
        \label{comparison_to_other}
    
    \section{Improving the Recommender Results}
        \label{improving_the_results}

\chapter{Conclusion and Future Work}
\label{conclusion}

zahrnul jsem knowledge-based recommender do matrix factorization (ale na to prijdu az v kapitole algorithms).

\chapter{Software tools}
\label{tools}
 - gedit, http://www.timtim.com (obrazky), Kile (latex),  pdfTeXk version 1.40.3 (Web2C 7.5.6)
    
    
%%% Seznam literatury
%%%
%%% Literatura se øadí abecednì. Úvádí se pouze literatura, na kterou se v textu odkazuje.
%%% Pøi odkazu na knihu se v¾dy uvádìjí èísla stránek.

\begin{thebibliography}{99}
%druhy literatury:
%    o universal recommenders
%    o algoritmech a jejich implementaci
%    case studies
\addcontentsline{toc}{chapter}{Bibliography}
% \bibitem{abraham-marsden}Abraham R., Marsden J. E.: {\em Foundations of Mechanics}, Addison-Wesley, Reading, 1985.
    
    \bibitem{patent}Geoffrey J. Hueter, Steven C. Quandt, Noble H. Hueter: \emph{Universal system and method for representing and predicting human behavior} \#20090248599, United States Patent Application Publication, 2009. http://www.freshpatents.com/-dt20091001ptan20090248599.php, http://www.freepatentsonline.com/20090248599.pdf

    \bibitem{netflix_solution}http://www.netflixprize.com/assets/GrandPrize2009\_BPC\_BellKor.pdf
    \bibitem{netflix_wiki}http://en.wikipedia.org/wiki/Netflix\_Prize
    \bibitem{netflix_benefit}http://www.nytimes.com/2009/09/22/technology/internet/22netflix.html
    \bibitem{netflix_end}http://blog.netflix.com/2010/03/this-is-neil-hunt-chief-product-officer.html
        http://glaros.dtc.umn.edu/gkhome/suggest/overview
    hybrid vec na duinu
        http://wwwis.win.tue.nl/hacdais2010/paper4short.pdf 
    \bibitem{survey}Gediminas Adomavicius and Alexander Tuzhilin: \emph{Towards the Next Generation of Recommender Systems:
A Survey of the State-of-the-Art and Possible Extensions}, 2005
    \bibitem{wiki_genome}http://en.wikipedia.org/wiki/Music\_Genome\_Project
    \bibitem{wiki_collaborative}http://en.wikipedia.org/wiki/Collaborative\_filtering
    \bibitem{wiki_slope_one}http://en.wikipedia.org/wiki/Slope\_One
    \bibitem{amazon}Amazon.com Recommendations Item-to-Item Collaborative Filtering http://www.win.tue.nl/\~laroyo/2L340/resources/Amazon-Recommendations.pdf
    \bibitem{bellkor_ieee}Matrix factorization techniques for recommender systems http://research.yahoo4.akadns.net/files/ieeecomputer.pdf
    \bibitem{bellkor_2009}
Yehuda Koren: The BellKor Solution to the Netflix Grand Prize
http://www.netflixprize.com/assets/GrandPrize2009\_BPC\_BellKor.pdf
    \bibitem{google_news}Google News Personalization: Scalable Online Collaborative Filtering http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.80.4329\&rep=rep1\&type=pdf
    
    \bibitem{white_paper}The Universal Recommender http://adsabs.harvard.edu/abs/2009arXiv0909.3472K
    \bibitem{duine}The Duine Framework http://duineframework.org
    \bibitem{knowledge_burke}Knowledge-based recommender systems \verb!http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.41.3078&rep=rep1&type=pdf!
    \bibitem{integrating_burke}Integrating Knowledge-based and Collaborative-filtering
               Recommender Systems
\verb!http://www.aaai.org/Papers/Workshops/1999/WS-99-01/WS99-01-011.pdf!
\bibitem{racofi}RACOFI: A Rule-Applying Collaborative Filtering System
\verb!http://www.daniel-lemire.com/fr/documents/publications/racofi_nrc.pdf!
\bibitem{knowledge_spain}A Knowledge Based Recommender System Based on Consistent Preference Relations 
\verb!http://www.springerlink.com/content/m64g474m7p0t4r26/!
\verb!http://books.google.cz/books?id=LN4dVFPXBioC&lpg=PP1&ots=EwNO8Bpeyy&dq=Intelligent%20Decision%20and%20Policy%20Making%20Support%20Systems&pg=PP1#v=onepage&q&f=false!
\bibitem{order}Learning to order things
\verb!http://www.jair.org/media/587/live-587-1790-jair.pdf!

http://ids.csom.umn.edu/faculty/gedas/papers/recommender-systems-survey-2005.pdf
odkazy:
    http://en.wikipedia.org/wiki/Recommender\_system
    http://www.deitel.com/ResourceCenters/Web20/RecommenderSystems/RecommenderSystemsConferences/tabid/1323/Default.aspx
    http://lucene.apache.org/mahout/taste.html\#useful .. tam toho neni moc
    Univerzalni recommender, projekty:
        Aura (dead since 2009):
            \bibitem{aura}The Advanced Universal Recommendation Architecture (AURA) Project home page. http://labs.oracle.com/projects/dashboard.php?id=196
            \bibitem{music_explaura}The Music Explaura, an experimental music recommender based on AURA. Currently inactive. http://music.tastekeeper.com/
            \bibitem{aura_wiki}The AURA project wiki. http://kenai.com/projects/aura/pages/Home
        Loomia (komercni):
            http://www.loomia.com/
        SUGGEST (dead since 200):
            http://glaros.dtc.umn.edu/gkhome/suggest/overview
            + http://pypi.python.org/pypi/pysuggest/1.0
        easyrec (opensource, vypada ze umi prd, ale bezi jako service):
            http://easyrec.org/api-js
        duine (opensource):
            http://duineframework.org
    knihovny na recommendaci
        mahout
            http://lucene.apache.org/mahout/
            http://svn.apache.org/repos/asf/mahout/
    
    algoritmy
        http://tastecliq.posterous.com/comparing-state-of-the-art-collaborative-filt
        tagy:
            http://stackoverflow.com/questions/2794272/tag-keyword-based-recommendation
        
        
    python to Java
        http://www.slideshare.net/onyame/mixing-python-and-java
        http://wiki.cacr.caltech.edu/danse/index.php/Communication\_between\_Java\_and\_Python
        Pres generovane c++
            http://pypi.python.org/pypi/JCC/
        nejak jinak (asi obracene)
            http://jepp.sourceforge.net/
        primo pres masiny (dead since 2009)
            http://hustleplay.wordpress.com/2010/02/18/jpype-tutorial/
            http://jpype.sourceforge.net/
            
            
        
    
 
% \bibitem{derbes}Derbes D.: {\em Reinventing the wheel: Hodographic solutions to the Kepler problems}, Am. J. Phys. {\bf 69} (2001) 481--489.
% \bibitem{kvasnica}Kvasnica J.: {\em Teorie elektromagnetického pole}, Academia, Praha, 1985.
\end{thebibliography}

\end{document}
